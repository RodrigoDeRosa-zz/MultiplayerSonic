Cliente:
    HECHO    - Cambiar colas toSend de <char*> a int (Va a ser un enum que represente a cada evento de SDL)
    HECHO               - Cambiar el socketReceive para que sea largo fijo. (idem abajo)
    HECHO               - Cambiar el clientReceive para que tenga largo fijo. (Igual que el server pero ahora en vez de un int es el struct de outMessage)
    HECHO               - Cambiar el thread de recepcion en clientCommunication para que maneje outMessages
    HECHO               - Cambiar colas received<char*> para que tenga outMessages
    HECHO               - El struct outMessage tiene que contemplar el ping
Server:
    HECHO               - Debe pingear acorde a lo que recibe el cliente (outMessage).
    HECHO               - Debe enviar outMessages
    - Destruir los estados de juego enviados a los clientes una vez que se enviaron
    HECHO               - El thread de recepcion de eventos no tiene que tener ningun if, lo que desencole van a ser directamente eventos conocidos.
main:
    HECHO               - Castear los estados que devuelve el juego a char* para que el server no se entere que es algo mas que char*
                        (Es decir, el server solo usa el sizeof(outMessage) [en connection.cpp])

Cosas hechas:
    HECHO Ya funciona lo que dice HECHO. Capaz haga falta una prueba mas potente para ver si falla. Fijate si podes hacer eso.
    HECHO A los out_message_t se les agrego un 'char ping' que indica si el mensaje es ping o no.
    ~ Los id tuvieron que ser ints porque no me dejaba acceder al char* del struct una vez que lo recibia del otro lado, fijate si lo podes arreglar. (sino se casteara en otro lado)
    ~ El cambio en el out_message_t es probable que haya que adaptarlo a lo que hicieron los chicos, pero no deberia ser dificil y se hace cuando se integra.
    HECHO Fijate de hacer pruebas con varios clientes y mandando mucha info. Hacete un dummy que vaya modificando posiciones y etc. para ver si anda bien.

Martin:
*Cambie el Socket, ahora tiene un segundo buffer interno y demas para el Receive (el Send no lo toque), con eso no se pisa data ni nada y es de 300B como para encolar ~10 mensajes sin procesar.
*El gameClient ahora acepta como ordenes "spam 10" y "spam 100" con un usleep definido entre cada encolada. Al momento de escribir esto el usleep era de 0.5 mseg, lo cual es buena performance.
*Tambien en el gameClient.cpp puse 2 funciones demostradas en la carpeta messagesh que tiran un dump hexadecimal del struct recibido, esto es util para comparar en el spam si se mantiene la data como deberia.
*En el server module el process_dummy para que quede mas claro, de cualquier manera es bastante pedorro pero sirve para poder chequear qué orden se mando.

*Qué falta: 
1)Lo que no diga hecho de la lista de arriba, osea si con el modelo hay que meter algun parche en el medio por los ints de id en vez de char* (tratemos de seguir usando el int si podemos, sino fue).
2)Ubicar bien dónde hay que meter en el main el pedazo del modelo.	
3)Revolear el logger en algun lado, son las 5:30 y me estoy muriendo. De ultima veo de hacerlo con todo ya integrado, total no afecta en nada.
