

void* reader_f(void* data)

DATA: Se la llama desde pthread_create(&reader_thread,reader_f,(void*) ARG);
con lo que sea ARG.

TIENE QUE:
	-inicializar algo? Tal vez esperar una señal de partida, porque el resto es blocking..
	while True:
		-pedir mutex del socket
		-hacer recv del socket, guardarlo en un buffer   !!!BLOCKING
		-soltar mutex
			-si recv es 0 avisar que se cerro el sock
			-si recv es <0 logear error
		-formatear el dato recibido
		-encolar el dato en la InQueue
	-cerrar lo que haga falta? No, en todo caso flaggear como cuando recv==0 y salir, otro se ocupa de cerrar.

---------------------------------------------------------------------------------------------

void* writer_f(void* data)

DATA: Se la llama desde pthread_create(&writer_thread,writer_f,(void*) ARG);
con lo que sea ARG.

TIENE QUE:
	-inicializar algo? Tal vez esperar una señal de partida, porque el resto es blocking..
	while True:
		-if (OutQueue.is_empty()) continue;   O PODRIA SER CON UN SLEEP ANTES PARA QUE NO CONSUMA TANTO!
		-dato = desencolar del OutQueue DE ESE SOCK
		-formatear?
		-pedir mutex
		-hacer sendv del dato formateado		!!!BLOCKING
		-soltar mutex
			-si es 0 o <0 reaccionar
	-cerrar lo que haga falta? No, en todo caso flaggear y salir

---------------------------------------------------------------------------------------------

void* accepter_f(void* data)

DATA: Se la llama desde pthread_create(&accepter_thread,accepter_f,(void*) ARG);
con lo que sea ARG.

TIENE QUE:
	-inicializar algo? No deberia, ya tendria que estar el socket+lo demas listo
	while(True):
		-if(flag de "no hay que leer mas") break;
		-socket nuevo = aceptar cx con timeout(para que no bloquee)
			-si error reaccionar
		-inicializar cx sobre el socket nuevo
	-cerrar lo que haga falta? No, en todo caso flaggear y salir. OJO! Cerrar este implica que el sv pasa a estar aislado del mundo! Debería ser server.shutdown()->poner el flag de chau->esto sale.

