Carpetas en orden de creacion y explicacion de por qué, con diferencias respecto de lo anterior

1)Serverclient1
Un servidor que espera cxs, cuando abren una le manda un msg y cierra la cx.
El cliente solo busca establecer la cx y despues muestra el msg recibido en pantalla.

-Esto solo sirve de demo, no tiene uso práctico

2)Selectserver1
Un servidor que espera cxs y NO MUESTRA ABSOLUTAMENTE NADA.
Cuando recibe una cx nueva la acepta y luego funciona como repartidor:
cada cliente que se conecta envia mensajes (como tiras de bits) y el sv se lo manda al resto de los clientes (EL SV NO MUESTRA MSGS)


-Esto ya implementa el select (==mutex) pero no multithreading.
-Antes de multithread habría que agregar un objeto (claramente singleton) para facilitar el manejo de cxs, hay loops horribles y cosas de muy bajo nivel al pedo. Posiblemente se haga en la prox iteracion.
-A futuro también habría que buscar forma de loggear en vez de printear (ojo a perror, intentar no usar redireccion).
-Cuando se implemente MT, joderán los flush (blocking) del logger? a lo mejor se puede mandar a otro thread, o tal vez otro proceso(intentar que no).

3)Selectserver1_5
Se cambian lugares de declaraciones de cosas, para probar el scope real que tienen. Se mantiene todo lo que se dijo en (2)
UPDATE: No se puede usar un vector más que para guardar las cxs activas debido a cómo funciona select y lo que le hace a los fd_set. Se puede llegar a usar un vector para cxs_activas pero no mucho más.

4)Selectserver2
Ahora tiene todo modularizado (se puede discutir si esta bien hecho o refactorizar).
No se usa ningun objeto pero tranquilamente se puede extender metiendo las f's adentro de un singleton.
También si se define una f handle_data(msg,sender) se puede hacer un thread.run(handle_data,args) y pasa a ser multithread.

-Sigue faltando uso de MT.
-No se usan objetos (para lectura es más dificil pero es mejor en performance).
-Falta pasar de prints a logger.

5)Client1-listener1
Es un client que se conecta al sv y solo imprime lo que le manda, es incapaz de enviar nada.
Corta si recibe un EOF(== se cierra la cx).

6)Client2-chatter1   NO TERMINADO
La idea es armar un client que pueda chatear de forma parecida a "telnet localhost 9034".
Se pretende poner en otro thread la f para recibir el string a enviar y enviarlo, asi se puede seguir loopeando.

7)Selectserver3 y 3_5
En selectserver3 se cambia el llamado a send por un wrapper con void* preparando para ser usado con threads.
En selectserver3_5 el llamado ya se hace lanzando un thread, así que ahora el envío de datos a los demás es llamando un thread por socket y mandando a enviar a cada uno el mensaje.

8)Server4
Se cambia (casi) toda la implementación, ahora el "main" loop lanza un thread para conexiones entrantes, a su vez cada cx aceptada abre su thread aparte para ser leida. Todavia no se implementa mandarle a los demas porque no hay un lugar dedicado para guardar:
1-los mensajes recibidos en orden (hacer un queue y un mutex para llamar a push)
2-los fd's abiertos para mandar.
Habra problemas de uso de recurso si trato de leer y mandar desde el mismo socket? Parece que no, y sino mutex (si se puede lo evitamos). 

9)Server5
5-0-1 a 5-0-2 recibe pero no manda
5-0-3 tiene una prueba de como desencolar, sigue sin mandar.

5-0-4 va a tener para mandar a todos.
5-0-5 va a tener un thread por socket también para mandar.

